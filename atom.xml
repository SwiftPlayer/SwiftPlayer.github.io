<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haofree</title>
  <subtitle>做自己所做，That&#39;s all</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/"/>
  <updated>2017-08-25T14:33:49.000Z</updated>
  <id>https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/</id>
  
  <author>
    <name>Haofree(SwiftPlayer)</name>
    <email>javafree@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SiriKit预研</title>
    <link href="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/07/14/SiriKit%E9%A2%84%E7%A0%94/"/>
    <id>https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/07/14/SiriKit预研/</id>
    <published>2017-07-14T05:34:15.000Z</published>
    <updated>2017-08-25T14:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、SiriKit介绍"><a href="#一、SiriKit介绍" class="headerlink" title="一、SiriKit介绍"></a>一、SiriKit介绍</h2><p><code>Siri</code>是一款苹果 iOS 系统提供的智能语音助手软件，它的全名是 <code>Speech Interpretation and Recognition Interface</code>。2011年 <code>Siri</code>第一次以 iOS 内置软件的形式随 <code>iPhone 4s</code> 一同问世之后，终于在 <code>WWDC 2016</code> 上，苹果开放了<code>Siri</code> 的 API，开发者们可以利用<code>SiriKit</code>将自己的服务提供给用户。<br>备注：<code>SiriKit</code>是系统调用，是一个语义处理结合扩展<code>UI</code>的框架，不是语音转文字的框架。</p>
<h4 id="1、SiriKit提供11类服务领域，详情请见苹果官方文档"><a href="#1、SiriKit提供11类服务领域，详情请见苹果官方文档" class="headerlink" title="1、SiriKit提供11类服务领域，详情请见苹果官方文档"></a>1、SiriKit提供11类服务领域，详情请见<a href="https://developer.apple.com/documentation/sirikit#//apple_ref/doc/uid/TP40016875-CH9-SW2" target="_blank" rel="external">苹果官方文档</a></h4><table>
<thead>
<tr>
<th>SiriKit 服务领域（Domain）</th>
<th>对应的意图(Intent)</th>
</tr>
</thead>
<tbody>
<tr>
<td>语音和视频通话 (VoIP calling)</td>
<td>INSearchCallHistoryIntent、INStartAudioCallIntent、INStartVideoCallIntent</td>
</tr>
<tr>
<td>发送消息 (Messaging)</td>
<td>INSendMessageIntent</td>
</tr>
<tr>
<td>收款或者付款 (Payments)</td>
<td>INSendPaymentIntent、INRequestPaymentIntent</td>
</tr>
<tr>
<td>列表和笔记 (Lists and Notes)</td>
<td>INCreateNoteIntent、INAppendToNoteIntent</td>
</tr>
<tr>
<td>视觉编码 (Visual Codes)</td>
<td>INGetVisualCodeIntent</td>
</tr>
<tr>
<td>图片搜索 (Photo search)</td>
<td>INSearchForPhotosIntent</td>
</tr>
<tr>
<td>管理锻炼 (Workouts)</td>
<td>INEndWorkoutIntent、INPauseWorkoutIntent 、INStartWorkoutIntent 、 INResumeWorkoutIntent 、INCancelWorkoutIntent</td>
</tr>
<tr>
<td>行程预约  (Ride booking)</td>
<td>INRequestRideIntent、INGetRideStatusIntent、 INListRideOptionsIntent、 INGetRideStatusIntent</td>
</tr>
<tr>
<td>车载管理 (Car Commands)</td>
<td>INGetCarLockStatusIntent、INSetCarLockStatusIntent、INActivateCarSignalIntent</td>
</tr>
<tr>
<td>车载系统 (CarPlay)</td>
<td>INSetAudioSourceInCarIntent、 INSetClimateSettingsInCarIntent、 INSetSeatSettingsInCarIntent、INSaveProfileInCarIntent、INSetProfileInCarIntent、INSetRadioStationIntent</td>
</tr>
<tr>
<td>餐厅订位  (Restaurant Reservations)</td>
<td>INBookRestaurantReservationIntent、  INGetAvailableRestaurantReservationBookingDefaultsIntent、 INGetAvailableRestaurantReservationBookingsIntent、 INGetRestaurantGuestIntent、 INGetUserCurrentRestaurantReservationBookingsIntent</td>
</tr>
</tbody>
</table>
<p>简单来说，在<code>SiriKit</code>的开发功能基本上就是在苹果提供的这些领域(<code>Domain</code>)上，在App开发中需要开发哪种领域的功能，就要在对应的<code>plist</code>文件中添加对应的<code>Intent</code>支持（<em>具体在哪个plist文件下文有说明</em>）那什么是<code>Intent</code>？<br>备注：SiriKit不是万能的，语义的处理流程要按照苹果的套路来（应用领域，意图），界面UI也套路来，不能调用App内部页面，具体UI会有SiriKit的UI扩展来实现。</p>
<h4 id="2、Intent的说明"><a href="#2、Intent的说明" class="headerlink" title="2、Intent的说明"></a>2、Intent的说明</h4><p>要想了解Intent，首先要清楚SiriKit的外部工作流程：<br>1)、 Siri完成语音识别和语义分析；<br>2)、会根据你词汇中的关键词识别出你属于上述11种领域中的哪一种；<br>3)、然后将结构化语音分析结果打包成一个某个领域（Domain）的意图(Intent)；<br>4)、接着交给支持这个意图（Intent）的第三方应<br>用，第三方应用被启动，从 传入的Intent中获取相应的信息，完成操作。<br>整个宏观的流程如下图：<br><img src="media/14994794583384/SiriKit%E6%B5%81%E7%A8%8B.png" alt="SiriKit流程"></p>
<p>例如，上图演示中提到了的例句 “用苏宁发消息给小明”，</p>
<p>领域 （Domain）：Messaging<br>意图 （Intent）：Send a message （INSendMessageIntent）<br>意图参数 （Intent Parameter）<br>收件人（recipients）：小明<br>消息内容（content）：空<br><strong>备注：（如果没有消息内容，这时就会涉及到Sikit的API中提供的处理机制，这个机制会调Siri反问你要发送什么内容，这个就涉及到下文提到的SiriKit相关功能和处理流程，会有不同的扩展和类在处理这个问题）</strong></p>
<h2 id="二、SiriKit功能开发介绍"><a href="#二、SiriKit功能开发介绍" class="headerlink" title="二、SiriKit功能开发介绍"></a>二、SiriKit功能开发介绍</h2><h4 id="1、发消息意图API（举例）"><a href="#1、发消息意图API（举例）" class="headerlink" title="1、发消息意图API（举例）"></a>1、发消息意图API（举例）</h4><h5 id="1）、发消息INSendMessageIntent配置"><a href="#1）、发消息INSendMessageIntent配置" class="headerlink" title="1）、发消息INSendMessageIntent配置"></a>1）、发消息INSendMessageIntent配置</h5><p>涉及到<code>SiriKit</code>的基本项目文件：<br><img src="media/14994794583384/siri%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="siri目录结构图"></p>
<p><img src="media/14994794583384/IntentConfig.png" alt="IntentConfig"></p>
<h5 id="2）、发消息INSendMessageIntent相关协议方法"><a href="#2）、发消息INSendMessageIntent相关协议方法" class="headerlink" title="2）、发消息INSendMessageIntent相关协议方法"></a>2）、发消息INSendMessageIntent相关协议方法</h5><p>一个标准的意图语音被<code>Siri</code>识别之后，<code>SiriKit</code>会先进入一个继承于<code>INExtension</code>的指定意图流程入口(<code>NSExtensionPrincipalClass</code>)类<code>IntentHandler.m</code>(默认类)。下面在这个相关类会处理整个流程：<br><img src="media/14994794583384/IntentLifeCycle.png" alt="IntentLifeCycle"></p>
<table>
<thead>
<tr>
<th>方法列表</th>
<th>中文解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-resolveRecipientsForSendMessage:withCompletion:</td>
<td>解析发送消息语义，提取意图对象</td>
</tr>
<tr>
<td>- resolveContentForSendMessage:withCompletion:</td>
<td>解析发送消息内容方法</td>
</tr>
<tr>
<td>- confirmSendMessage:completion:</td>
<td>确认方法</td>
</tr>
<tr>
<td>- handleSendMessage:completion:</td>
</tr>
</tbody>
</table>
<p> 处理方法 |</p>
<p>意图的生命周期如下图文描述：</p>
<p>一个典型的<code>Intent</code>事件的处理过程中有这三个步骤<code>Resolve</code>、<code>Confirm</code>和<code>Handle</code></p>
<ol>
<li><code>Resolve</code>阶段。在<code>Siri</code>获取到用户的语音输入之后，生成一个<code>INIntent</code>对象，将语音中的关键信息提取出来并且填充对应的属性。这个对象在稍后会传递给我们设置好的<code>INExtension</code>子类对象进行处理，根据子类遵循的不同协议来选择不同的解决方案。</li>
</ol>
<ol>
<li><code>Confirm</code>阶段。在上一个阶段通过<code>handlerForIntent:(INIntent *)</code>返回了处理<code>Intent</code>的对象，此阶段会依次调用<code>confirm</code>打头的实例方法来判断<code>Siri</code>填充的信息是否完成。匹配的判断结果包括<code>Exactly one match</code>、<code>Two or more matches</code>以及<code>No match</code>三种情况。这个过程中可以让<code>Siri</code>向用户征求更具体的参数信息。</li>
</ol>
<ol>
<li><code>Handle</code>阶段。在<code>confirm</code>方法执行完成之后，<code>Siri</code>进行最后的处理阶段，生成答复对象，并且向此Intent对象确认处理结果然后执显示结果给用户看。<br><img src="media/14994794583384/resolve_confirm_handle_cycle.png" alt="resolve_confirm_handle_cycle"></li>
</ol>
<h5 id="3）、发消息INSendMessageIntent的意图对象"><a href="#3）、发消息INSendMessageIntent的意图对象" class="headerlink" title="3）、发消息INSendMessageIntent的意图对象"></a>3）、发消息INSendMessageIntent的意图对象</h5><p>具体在各个阶段的方法里怎么代码实现，主要是要理解<code>INSendMessageIntent</code>的对象属性，通过解析对象，可以在各个阶段用获取到的对象进行相关程序逻辑编码。如：</p>
<table>
<thead>
<tr>
<th>对象名称</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>recipients</code></td>
<td><code>NSArray&lt;INPerson*&gt;</code></td>
<td>Contacts to whom the message should be sent.</td>
</tr>
<tr>
<td><code>content</code></td>
<td><code>NSString</code></td>
<td>Body text of the message.</td>
</tr>
<tr>
<td><code>groupName</code></td>
<td><code>NSString</code></td>
<td>Body text of the message.</td>
</tr>
<tr>
<td><code>serviceName</code></td>
<td><code>NSString</code></td>
<td>Specified service for the message.</td>
</tr>
<tr>
<td><code>sender</code></td>
<td><code>INPerson</code></td>
<td>The person, or account, sending the message.</td>
</tr>
</tbody>
</table>
<p>通过流程方法里获取到<code>INSendMessageIntent</code>对象进行解析，匹配，处理，这个过程还涉及到返回的处理。每一个解析方法都需要得到一个<code>INIntentResolutionResult</code>类型的实例，用来保存校验结果。</p>
<p><code>INIntentResolutionResult</code>及其子类有不同的构造方法生成不同类型的结果，用来指定和Siri的交互。</p>
<table>
<thead>
<tr>
<th>值类型 <code>INIntentResolutionResult</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+ (instancetype)needsValue;</code></td>
<td>需要一个值，Siri会提示用户给一个值</td>
</tr>
<tr>
<td><code>+ (instancetype)notRequired;</code></td>
<td>不是必要的，是否给值都会过这个resolve</td>
</tr>
<tr>
<td><code>+ (instancetype)unsupported;</code></td>
<td>不支持的，Siri会提示用户这个值不被支持</td>
</tr>
<tr>
<td><code>+(instancetype)successWithResolvedValue:(BOOL)resolvedValue;</code></td>
<td>成功解析</td>
</tr>
<tr>
<td><code>+(instancetype)confirmationRequiredWithValueToConfirm:(nullable NSNumber *)valueToConfirm;</code></td>
<td>Siri提示用户确认当前是否是一个bool值</td>
</tr>
</tbody>
</table>
<p>当一个<code>intent</code>的所有参数都成功解析了，处理程序就会向用户询问是否确认这个<code>intent</code>的细节，并且提供一个建议响应。当所有参数被成功解析后，或者在不要求所有参数进行解析，那么就认为是解析成功。<br>在确认期间，就可以执行所有的<code>intent</code>参数的附加验证，以确保你可以使用该信息来执行所请求的服务。如果之前的解析函数是单元测试，那么这个确认函数就是集成测试，保证所有输入参数正确。</p>
<p>最后一个处理<code>intent</code>的阶段，就是执行与这个<code>intent</code>相关的动作。在<code>-handleSendPayment:completion</code>函数中做相应业务逻辑，需要注意的是你在<code>Extension</code>中做的修改也应当反应到App主程序当中，所以需要提供任务的数据给到App。<code>SiriKit</code>提供了一个包含<code>intent</code>细节（<code>INIntent、INIntentResponse）</code>的<code>InInteraction</code>对象，你可以使用<code>userActivityInstance.interaction</code>得到它，在App启动时调用<br><code>- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler</code><br>函数处理来自<code>Extension</code>的数据。</p>
<h5 id="4）、根据流程方法处理之后，如何与主程序通信"><a href="#4）、根据流程方法处理之后，如何与主程序通信" class="headerlink" title="4）、根据流程方法处理之后，如何与主程序通信"></a>4）、根据流程方法处理之后，如何与主程序通信</h5><p>轻量级通信可采用这个办法：<br>1）、在<code>handling</code>阶段在<code>NSUserActivity</code>存储相应的信息，字典或字符串都行（如上<code>handling</code>阶段代码）。<br>2）、在<code>AppDelegate</code>，获取<code>NSUserActivity</code>所存储的信息。<br>3）、发送通知给所需要的地方。<br>4）、接收到通知后对主程序进行相应操作。</p>
<p><em>备注：确认消息发送之后的逻辑也可以在处理阶段编码解决</em></p>
<p>有关在AppDelegate中处理SiriKit的Intent可以参考<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623072-application?language=objc" target="_blank" rel="external">相关苹果官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//AppDelegate.m</div><div class="line">- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">   continueUserActivity:(NSUserActivity *)userActivity</div><div class="line">restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler &#123;</div><div class="line">    if ([userActivity.interaction.intent isKindOfClass:[INSendMessageIntent class]]) &#123;</div><div class="line">        INSendMessageIntent *intent = (INSendMessageIntent *)(userActivity.interaction.intent);</div><div class="line">        NSLog(@&quot;%@&quot;,[[intent.recipients lastObject] displayName]);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、自定义界面-Intent-UI-Extension"><a href="#2、自定义界面-Intent-UI-Extension" class="headerlink" title="2、自定义界面(Intent UI Extension)"></a>2、自定义界面(Intent UI Extension)</h4><p>运用SiriKit开发相关功能，UI是依赖于<code>Intent UI Extension</code>，<code>SiriKit</code>并不能从系统层面调用App内部<code>UI</code>，只能调用打开App和<code>SirKit</code>自定义<code>UI</code>。</p>
<p>系统创建了<code>ViewController</code>，加载视图，调用<code>viewDidLoad</code>方法并且调用了<code>INUIHostedViewControlling</code>协议的<code>configureWithInteraction:context:completion:</code>方法，传递了一个交互对象，用于配置界面。 当配置完成后，<code>ViewController</code>就会展示在<code>Siri</code>或者<code>Maps</code>应用界面的空白部分。这时会调用<code>viewWillAppear/viewDidAppea</code>r方法。<br>当视图消失时，也会调用生命周期的<code>viewWillDisappear/viewDidDisappear</code>方法。</p>
<p><img src="media/14994794583384/siriUILifeCycle.png" alt="siriUILifeCycle"></p>
<h4 id="关于控制器的使用，苹果给出了几点注意事项："><a href="#关于控制器的使用，苹果给出了几点注意事项：" class="headerlink" title="关于控制器的使用，苹果给出了几点注意事项："></a>关于控制器的使用，苹果给出了几点注意事项：</h4><ol>
<li>切换子控制器来展示不同类型的内容。 你的Intents UI扩展只有一个主视图控制器，如果你想为不同的Intents展示不同的内容，你需要使用不同的视图。可以在<code>configureWithInteraction:context:completion:</code>这个方法里面，根据提供的intentObject来创建不同的子视图。</li>
</ol>
<ol>
<li>在你的视图控制器可用的期间，动态调整内容。 在 <code>viewDidAppear</code>:方法里面才开始启动动画，在<code>viewWillDisappear</code>: 方法里面要结束动画。</li>
</ol>
<ol>
<li>尽快的配置好你的视图控制器，这样<code>Siri</code>才能更快的展示它。 你的视图控制器也许不会在屏幕上停留太久，所以尽量利用本地资源以及提供的<code>INInteraction</code>对象来配置你的设置。如果你需要从服务器拉取更多的信息，请异步完成，并在稍后再更新你的界面。</li>
</ol>
<ol>
<li><strong>请不要在界面里面展示广告</strong>。你可以展示你自己的品牌信息，但是你不能够加入其它广告。<h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2>发消息例子：<br>对 <code>Siri</code>说：“用演示给小明发消息”<br><img src="media/14994794583384/IMG_0003.png" alt="IMG_0003"></li>
</ol>
<p>转账例子：<br><img src="media/14994794583384/IMG_0009.png" alt="IMG_0009"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、SiriKit介绍&quot;&gt;&lt;a href=&quot;#一、SiriKit介绍&quot; class=&quot;headerlink&quot; title=&quot;一、SiriKit介绍&quot;&gt;&lt;/a&gt;一、SiriKit介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Siri&lt;/code&gt;是一款苹果 iOS 系统提供的智能
    
    </summary>
    
    
      <category term="iOS开发" scheme="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS移动端的安全架构设计</title>
    <link href="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/06/25/iOS%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/06/25/iOS移动端的安全架构设计/</id>
    <published>2017-06-25T14:48:04.000Z</published>
    <updated>2017-08-27T05:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>伴随着移动产品广泛应用与快速发展，移动客户端的安全问题越来越受重视。我这里主要谈谈iOS移动端的安全架构设计。</p>
</blockquote>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>移动端的安全一般可以理解为两个方面：<strong><em>本地安全</em></strong> 、<strong><em>通信安全</em></strong>。</p>
<blockquote>
<p><strong>1、本地安全:</strong><br>本地安全主要指客户端本地环境与数据的安全，以及代码被破解获得所导致的安全问题，如：明文存储问题，恶意二次打包问题，越权操作问题等。</p>
<p><strong>2、通信安全:</strong><br>通信安全主要指客户端与服务端进行数据交互时被拦截破获导致的安全问题。如采取明文进行密码或者数据传输等问题。</p>
</blockquote>
<p>关于一些移动端安全的认识还有web安全等等，请参考文章：<a href="https://zhuanlan.zhihu.com/p/26233460?refer=youzanmobile" target="_blank" rel="external">移动端本地安全解决方案</a></p>
<h2 id="二、安全加密基础的快速认识"><a href="#二、安全加密基础的快速认识" class="headerlink" title="二、安全加密基础的快速认识"></a>二、安全加密基础的快速认识</h2><p>加密分为<strong>对称加密</strong>和<strong>非对称加密</strong>。<br> <strong>1、对称加密</strong><br>加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥，也就是共享密钥密码。（<em>ps:这个很好理解吧</em>）  常用的对称加密算法：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
</tr>
</thead>
<tbody>
<tr>
<td>DES</td>
<td>Data Encryption Standard</td>
</tr>
<tr>
<td>3DES</td>
<td>Triple DES</td>
</tr>
<tr>
<td>AES</td>
<td>dvanced Encryption Standard</td>
</tr>
</tbody>
</table>
<p> <strong>2、非对称加密</strong><br> 加密使用的密钥和解密使用的密钥是不相同的。 （<em>ps:这个不好理解？不好理解请好好看看非对称加密算法原理</em>） 简单来说就是有一套算法可以实现你用公钥加密的信息，对方用保留的私钥进行解密。</p>
<blockquote>
<p>常说的公钥密码就是指非对称密码，公钥加密就是一种非对称加密。</p>
</blockquote>
<p> 最常用的是RSA算法。<a href="http://www.cfca.com.cn/20150811/101230777.html" target="_blank" rel="external">RSA的演算方法是：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1)用户选择2个够大的保密质数q、p(一般为100位以上十进数)</div><div class="line">2)令n＝pq，n是公开的，从n分解除qp是极其困难的。</div><div class="line">n的欧拉函数：Φ(n)＝(p-1)(q-1)</div><div class="line">Φ(n)小于等于n，并与n互质</div><div class="line">3)选择一个相对大的整数e作为加密指数，使e与Φ(n)互质，</div><div class="line">4)解同等方程：</div><div class="line">ed＝1modΦ(n)</div><div class="line">求出解密指数d</div><div class="line">5)设M、C分别为要加密的明文和被加密的密文(M、C小于n)</div><div class="line">则：加密运算为：C＝Memod n</div><div class="line">解密运算为：M＝Cdmod n</div><div class="line">6)每个用户都有一组密钥(e、d、n)</div><div class="line">(e，n)为PK&apos;可以公开在手册上的公钥，e为加密指数，</div><div class="line">(d，n)为SK’(或PV)是用户保密的私钥</div><div class="line">将p.q销毁</div><div class="line">7)要求明文X</div><div class="line">举例：</div><div class="line">1) 选两个质数： p＝47 q＝71</div><div class="line">2)计算： n＝pq＝3337 Φ(n)＝(47-1)(71-1)＝3220</div><div class="line">3) e必须与Φ(n)互质，选e＝79</div><div class="line">4) 计算：ed=1modΦ(n)＝1mod(3220)</div><div class="line">d＝1019</div><div class="line">将e、n公布，d保密，p.q消毁</div><div class="line">如有一明文 M＝6882326879666683要加密，则先将M分割成多块：</div><div class="line">m1＝688,m2＝232,m3＝687,m4＝966,m5＝668,m6＝3</div><div class="line">将第1块M1加密后得密文C1：</div><div class="line">C1＝m1e(mod3337)＝68879(mod3337)＝1570</div><div class="line">依次对各区块加密后得密文C：</div><div class="line">C＝15702756271422762423158</div><div class="line">对C1解密得m1</div><div class="line">M1＝C1d(mod3337)＝15701019(mod3337)=688</div><div class="line">依次解密得原文M。</div></pre></td></tr></table></figure>
<p>　　那么问题来了，我们遇到的PBE（Password Based Encryption，基于口令加密）加密啊都是什么呢。详情可以去了解下，这里强调一点，PBE算法的应用还是在对称加密范畴。至于哪种加密方案适合自己的场景，这也是我们今天iOS移动端安全架构设计的时候需要考虑的。<br><strong>知识点延伸：</strong><br><em>1、对称密码与公钥密码对比，消息认证码与数字签名的对比</em></p>
<table>
<thead>
<tr>
<th>对象属性</th>
<th>对称密码</th>
<th>公钥密码（非对称密码）</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送者</td>
<td>用共享密钥加密-双方持有</td>
<td>用公钥加密</td>
</tr>
<tr>
<td>接收者</td>
<td>用共享密钥加密-双方持有</td>
<td>用私钥解密</td>
</tr>
<tr>
<td>密钥配送问题</td>
<td>存在</td>
<td>不存在，但公钥需要另外认证</td>
</tr>
<tr>
<td>机密性</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对象属性</th>
<th>消息认证码</th>
<th>数字签名</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送者</td>
<td>用共享密钥计算MAC值</td>
<td><strong><em>用私钥生成签名</em></strong></td>
</tr>
<tr>
<td>接收者</td>
<td>用共享密钥计算MAC值</td>
<td><strong><em>用公钥验证签名</em></strong></td>
</tr>
<tr>
<td>密钥配送问题</td>
<td>存在</td>
<td>不存在，但公钥需要另外认证</td>
</tr>
<tr>
<td>完整性</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>认证</td>
<td>✅（仅限通信对象双方）</td>
<td>✅ （可适用于任何第三方）</td>
</tr>
<tr>
<td>防止否认</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><em>2、公钥密码与数字签名的密钥适用方式</em></p>
<table>
<thead>
<tr>
<th>对象属性</th>
<th>公钥</th>
<th>私钥</th>
</tr>
</thead>
<tbody>
<tr>
<td>公钥密码</td>
<td>发送者加密时使用</td>
<td>接收者解密时使用</td>
</tr>
<tr>
<td>数字签名</td>
<td><em>验证者验证签名时使用</em></td>
<td><em>签名者生成签名时使用</em></td>
</tr>
<tr>
<td>谁持有密钥？</td>
<td>只要需要，可任何人都可以持有</td>
<td>个人持有</td>
</tr>
</tbody>
</table>
<p>数字签名就是利用非对称加密的原理，只是用法下不一样，反着的。另外为公钥加上数字签名就是证书。</p>
<h2 id="二、iOS移动端设计的安全考量"><a href="#二、iOS移动端设计的安全考量" class="headerlink" title="二、iOS移动端设计的安全考量"></a>二、iOS移动端设计的安全考量</h2><p>移动客户端设计时，除了上述宽泛的本地安全和通信安全需要考量，具体到模块与业务需要开发者作哪些思考呢？本地密码存储安全怎么保证，客户端web页面怎么防止被劫持，客户端在设计交易时如何考虑安全性等等问题。如今苹果开始强制接口使用HTTPS协议也是为为了增强安全性，但开发者在客户端设计之初也需要考虑这些安全问题，建立一些基础的安全模块。<br><em>（ps：至于涉及到金融类App考虑的安全问题就更多，如交易安全，私钥如何存储等）</em></p>
<h4 id="1、安全需求分析"><a href="#1、安全需求分析" class="headerlink" title="1、安全需求分析"></a>1、安全需求分析</h4><p>加密原则：</p>
<blockquote>
<ol>
<li>App代码安全，包括代码混淆，加密或者app加壳。</li>
<li>App数据存储安全，主要指在磁盘做数据持久化的时候所做的加密。</li>
<li>App网络传输安全，指对数据从客户端传输到Server中间过程的加密，防 止网络世界当中其他节点对数据的窃听。</li>
</ol>
</blockquote>
<p><strong>本地存储安全：</strong><br>1)、明文存储，过度依赖系统安全性（iOS：Keychain/UserDefault）<br>2)、恶意二次打包<br>3)、容易被逆向，被调试<br>4)、敏感信息写入代码</p>
<p><strong>网络通信安全：</strong><br>1)、HTTP传输被劫持（苹果开始强制接口使用HTTPS协议）<br>2)、明文传输数据</p>
<blockquote>
<p><em>另外由本地安全延伸出来：</em><br>1)、本地自动登录如何存储私钥，如何解决又方便用户，又保证安全。<br>2)、金融类、支付类App如何解决支付安全问题，二维码支付的安全问题等等。</p>
</blockquote>
<h4 id="2、需求技术准备"><a href="#2、需求技术准备" class="headerlink" title="2、需求技术准备"></a>2、需求技术准备</h4><p>1)、针对本地明文存储的安全漏洞，自然是要本地进行加密，本地加密只是增加了一些复杂度，但也是有效的。比如利用对称算法，通过简单的URLENCODE ＋ BASE64编码防止数据明文传输</p>
<p>2)、对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验。发送请求也有PBE加密等等</p>
<p>3)、对于重要数据，使用RSA进行数字签名，起到防篡改作。</p>
<p>4)、 对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地数据加密</td>
<td>对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息。</td>
</tr>
<tr>
<td>URL编码加密</td>
<td>对程序中出现的URL进行编码加密，防止URL被静态分析</td>
</tr>
<tr>
<td>网络传输数据加密</td>
<td>对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取</td>
</tr>
<tr>
<td>方法体，方法名高级混淆</td>
<td>对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码</td>
</tr>
<tr>
<td>程序结构混排加密</td>
<td>对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低</td>
</tr>
</tbody>
</table>
<h2 id="三、iOS移动端安全模块设计"><a href="#三、iOS移动端安全模块设计" class="headerlink" title="三、iOS移动端安全模块设计"></a>三、iOS移动端安全模块设计</h2><h4 id="1、基础模块"><a href="#1、基础模块" class="headerlink" title="1、基础模块"></a>1、基础模块</h4><p><strong>1)、对称加密工具类</strong><br>提供iOS客户端的基础对称加密算法（MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ IDEA \ DSA \ AES）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">//Base64加密</div><div class="line">+(NSString *)encodeBase64:(NSString *)input &#123;</div><div class="line">    NSData *data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];</div><div class="line">    data = [GTMBase64 encodeData:data];</div><div class="line">    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</div><div class="line">    NSLog(@&quot;encodeBase64 == %@&quot;,base64String);</div><div class="line">    return base64String;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Base64编码</div><div class="line">+(NSString *)base64EncodeString:(NSString *)string &#123;</div><div class="line">    //1.先把字符串转换为二进制数据</div><div class="line">    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    //2.对二进制数据进行base64编码，返回编码后的字符串</div><div class="line">    //这是苹果已经给我们提供的方法</div><div class="line">    NSString *str = [data base64EncodedStringWithOptions:0];</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Base64解密</div><div class="line">+(NSString *)decodeBase64:(NSString *)input &#123;</div><div class="line">    NSData *data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];</div><div class="line">    data = [GTMBase64 decodeData:data];</div><div class="line">    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</div><div class="line">    NSLog(@&quot;decodeBase64 == %@&quot;,base64String);</div><div class="line">    return base64String;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//对base64编码后的字符串进行解码</div><div class="line">+(NSString *)base64DecodeString:(NSString *)string &#123;</div><div class="line">    //1.将base64编码后的字符串『解码』为二进制数据</div><div class="line">    //这是苹果已经给我们提供的方法</div><div class="line">    NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0];</div><div class="line">    //2.把二进制数据转换为字符串返回</div><div class="line">    NSString *str =  [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Base64 字符串解码成 字符串</div><div class="line">+(NSString *)decodeBase64ToHexString:(NSString *)input &#123;</div><div class="line">    //1.将base64编码后的字符串『解码』为二进制数据</div><div class="line">    //这是苹果已经给我们提供的方法</div><div class="line">    NSData *myD = [[NSData alloc]initWithBase64EncodedString:input options:0];</div><div class="line">    Byte *bytes = (Byte *)[myD bytes];</div><div class="line">    //下面是Byte 转换为16进制。</div><div class="line">    NSString *hexStr=@&quot;&quot;;</div><div class="line">    for(int i=0;i&lt;[myD length];i++) &#123;</div><div class="line">        NSString *newHexStr = [NSString stringWithFormat:@&quot;%x&quot;,bytes[i]&amp;0xff];///16进制数</div><div class="line">        if([newHexStr length]==1)</div><div class="line">            hexStr = [NSString stringWithFormat:@&quot;%@0%@&quot;,hexStr,newHexStr];</div><div class="line">        else</div><div class="line">            hexStr = [NSString stringWithFormat:@&quot;%@%@&quot;,hexStr,newHexStr];</div><div class="line">    &#125;</div><div class="line">    return hexStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//DES 加密</div><div class="line">+(NSData *)encryptUseDES:(NSData *)plainText key:(Byte *)key &#123;</div><div class="line">    NSData *textData = plainText;</div><div class="line">    NSUInteger dataLength = [textData length];</div><div class="line">    unsigned char buffer[1024];</div><div class="line">    memset(buffer, 0, sizeof(char));</div><div class="line">    size_t numBytesEncrypted = 0;</div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES,</div><div class="line">                                          kCCOptionECBMode,</div><div class="line">                                          key, kCCKeySizeDES,</div><div class="line">                                          nil,</div><div class="line">                                          [textData bytes], dataLength,</div><div class="line">                                          buffer, 1024,</div><div class="line">                                          &amp;numBytesEncrypted);</div><div class="line">    if (cryptStatus == kCCSuccess) &#123;</div><div class="line">        NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted];</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//DES 解密</div><div class="line">+(NSData *)decrypUseDES:(NSData *)plainText key:(Byte *)key &#123;</div><div class="line">    NSData *cipherdata = plainText;</div><div class="line">    unsigned char buffer[1024];</div><div class="line">    memset(buffer, 0, sizeof(char));</div><div class="line">    size_t numBytesDecrypted = 0;</div><div class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmDES,</div><div class="line">                                          kCCOptionECBMode,</div><div class="line">                                          key, kCCKeySizeDES,</div><div class="line">                                          nil,</div><div class="line">                                          [cipherdata bytes], [cipherdata length],</div><div class="line">                                          buffer, 1024,</div><div class="line">                                          &amp;numBytesDecrypted);</div><div class="line">    if(cryptStatus == kCCSuccess) &#123;</div><div class="line">        NSData *plaindata = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesDecrypted];</div><div class="line">        return plaindata;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/MD5加密返回Nsdata</div><div class="line">+(NSData *)encodeMD5:(NSData *)input &#123;</div><div class="line"> unsigned char result[CC_MD5_DIGEST_LENGTH];</div><div class="line"> CC_MD5(input.bytes, (CC_LONG)input.length, result);</div><div class="line"> NSData *data =[[NSData alloc] initWithBytes:result length:CC_MD5_DIGEST_LENGTH];</div><div class="line"> return data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如下，生成是小写的MD5的字符串，如果要生成大写的，只需要把</div><div class="line">[ret appendFormat:@&quot;%02X&quot;,result[i]];中的 &quot;%02X&quot;的 X改成小写的 x即可。</div><div class="line"></div><div class="line">//MD5加密返回Nsstring</div><div class="line">+(NSString *)MD5HexDigest:(NSData *)input &#123;</div><div class="line"> unsigned char result[CC_MD5_DIGEST_LENGTH];</div><div class="line"> CC_MD5(input.bytes, (CC_LONG)input.length, result);</div><div class="line"> NSMutableString *ret = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH*2];</div><div class="line"> for (int i = 0; i&lt;CC_MD5_DIGEST_LENGTH; i++)  &#123;</div><div class="line">     [ret appendFormat:@&quot;%02X&quot;,result[i]];</div><div class="line"> &#125;</div><div class="line"> return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2)、非对称加密工具类</strong><br>iOS中的Security.framework提供了对RSA算法的支持。这种方式需要对密匙对进行处理，根据public key生成证书，通过private key生成p12格式的密匙。<br>除了Secruty.framework，也可以将openssl库编译到iOS工程中，这可以提供更灵活的使用方式。<br>开源的：<a href="https://github.com/reference/OpenSSLRSAWrapper">OpenSSLRSAWrapper</a> </p>
<h4 id="2、一些场景方案设计举例：（登录场景token）"><a href="#2、一些场景方案设计举例：（登录场景token）" class="headerlink" title="2、一些场景方案设计举例：（登录场景token）"></a>2、一些场景方案设计举例：（登录场景token）</h4><p><strong>1)、一般的登陆：</strong><br>客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：</p>
<blockquote>
<ol>
<li>客户端向服务器第一次发起登录请求（不传输用户名和密码）。</li>
<li>服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。</li>
<li>客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。</li>
<li>服务器利用保留的私钥对密文进行解密，得到真正的密码。</li>
</ol>
</blockquote>
<p><strong>2)、token加密：</strong><br>再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展：</p>
<blockquote>
<ol>
<li>客户端向服务器第一次发起登录请求（不传输用户名和密码）。服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。</li>
<li>客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。</li>
<li>服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。</li>
<li>客户端利用自己生成的私钥对token密文解密， 得到真正的token。</li>
</ol>
</blockquote>
<p>图示如下：<br><img src="http://upload-images.jianshu.io/upload_images/2646525-a998be593c3796f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>3)、登录保持（也就是http/https数据请求阶段）</strong><br>引入token后，http/https请求被获取问题便可得到解决。 客户端将token和其它的一些变量， 利用散列加密算法得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token，利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端。（支付宝一样的机制）结构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/2646525-20c69d64d5b07cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>注：token失效的两种情况：</p>
<pre><code>1、用户登录出系统
2、token在后台的规定时间内失效（每个token都是有时间效应的）
</code></pre><p>失效原理：在服务器端的redis中删除相应key为session的键值对。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文只是初步介绍了一些加密的基础知识和iOS客户端安全设计时的基本思路，为大家提供一种参考。当然一些金融类和支付类的App对安全性的要求更高，在支付、扫码等环节的安全设计方案可能需要更加的完善，甚至离线支付时的私钥分端保存等等，这些都是需要思考的，也希望大家给出好的建议和方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伴随着移动产品广泛应用与快速发展，移动客户端的安全问题越来越受重视。我这里主要谈谈iOS移动端的安全架构设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
    
      <category term="iOS开发" scheme="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>打造更简洁的DataModel和ViewModel</title>
    <link href="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/03/24/%E6%89%93%E9%80%A0%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84DataModel%E5%92%8CViewModel/"/>
    <id>https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/2017/03/24/打造更简洁的DataModel和ViewModel/</id>
    <published>2017-03-24T08:27:07.000Z</published>
    <updated>2017-08-25T15:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>很多人试图解决 MVC 这种架构下 Controller 比较臃肿的问题，这里我分享一种简洁易懂的Model层，致力于打造更为简洁的DataModel和ViewModel层，同时也适用Controller更加简洁。下面一起分享学习。<a href="https://github.com/SwiftPlayer/ZHModel_Demo">源码：ZHModel_Demo</a></p>
</blockquote>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>对于iOS的APP架构，有很多说法和实践，包括<a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">MVC、MVVM、MVCS、VIPER</a>等等。我相信大部分开发者都热衷于MVC这种模式，我们对于 MVC 这种设计模式真的用得好吗？其实不是的，MVC 这种分层方式虽然清楚，但是如果使用不当，很可能让大量代码都集中在 Controller 之中。<br>ZHModel_Demo，提供简洁的DataModel和ViewModel示例。将数据请求封装，用ViewModel层连接控制器和数据，同时用属性映射分离出DataModel层，使数据更清晰，更重要的是将 Controller瘦身。</p>
<h1 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h1><blockquote>
<p>不论是哪种设计方式，总的架构都是上述那几种，所谓剑法无穷，万剑归宗。但今天我们讨论的是如何将DataModel和ViewModel设计得简洁清晰，可复用。</p>
</blockquote>
<p>这里MVVM 的优点拿来借鉴。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。这样抽象之后，View 只接受 ViewModel，而 Controller 只需要传递 ViewModel 这么一行代码。而另外构造 ViewModel 的过程，我们就可以移动到另外的类中了。在具体实践中，我们专门创建构造 ViewModel 工厂类，参见工厂模式。另外，我们也将数据模型通过属性映射对应到DataModel，这样使得所有来回的数据模型清晰可见，容易同意修改和复用。同时也可以专门将数据存取都抽将到一个 Service 层，由这层来提供 ViewModel 的获取。</p>
<h1 id="三、码上说话"><a href="#三、码上说话" class="headerlink" title="三、码上说话"></a>三、码上说话</h1><blockquote>
<p>下面我分享下代码，看看DataModel和ViewModel有什么优势或者不足的地方</p>
</blockquote>
<h4 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/2646525-a34cee8bb04e6562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构.png"><br>我们熟知的程序包含：网络请求、数据、控制器（视图，业务？），有时会把这几个关系弄得绕来绕去，导致代码臃肿，不好复用和维护。但所有情况无非就是：</p>
<blockquote>
<p>1、数据怎么来？<br>2、数据怎么桥接？<br>3、数据怎么呈现？</p>
</blockquote>
<h6 id="1）、数据怎么来？"><a href="#1）、数据怎么来？" class="headerlink" title="1）、数据怎么来？"></a>1）、数据怎么来？</h6><p>上述目录解析：</p>
<blockquote>
<p>1、网络请求封装成<strong>NetRequest</strong>模块（还包括<strong>HTTPClient</strong>类，这里略）<br>2、数据请求总出口封装在<strong>ZHRequestMethod</strong>类中<br>3、将收到的数据映射到数据模型DataModel(基于<strong>ZHResponseBaseModel  </strong>  )</p>
</blockquote>
<h6 id="1）、数据怎么桥接？"><a href="#1）、数据怎么桥接？" class="headerlink" title="1）、数据怎么桥接？"></a>1）、数据怎么桥接？</h6><p>上述目录解析：</p>
<blockquote>
<p>1、数据模型和View的桥接用到了ViewModel（基于<strong>ZHViewBaseModel</strong>）<br>2、 用继承于<strong>ZHViewBaseModel</strong>的<strong>PublicViewBaseModel</strong>处理具体网络请求，数据模型和控制器视图的关系</p>
</blockquote>
<h6 id="1）、数据怎么呈现？"><a href="#1）、数据怎么呈现？" class="headerlink" title="1）、数据怎么呈现？"></a>1）、数据怎么呈现？</h6><blockquote>
<p>我们的目的是什么？就是为了让数据呈现更加简洁，让呈现数据的视图控制器变的优雅。视图呈现利用ViewModel轻松展示。</p>
</blockquote>
<h4 id="2、数据模型DataModel层"><a href="#2、数据模型DataModel层" class="headerlink" title="2、数据模型DataModel层"></a>2、数据模型DataModel层</h4><p>数据模型DataModel分为网络请求<strong><em>返回参数模型</em></strong>和<strong><em>发送参数模型</em></strong><br><strong>返回参数模型基类ZHResponseBaseModel</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHResponseBaseModel.h</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ZHResponseBaseModel : NSObject</div><div class="line"></div><div class="line">- (void)decodeJsontoDictionary:(NSDictionary*)dic;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHResponseBaseModel.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ZHResponseBaseModel.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation ZHResponseBaseModel</div><div class="line"></div><div class="line">- (void)decodeJsontoDictionary:(NSDictionary*)dic&#123;</div><div class="line">    if (![dic isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    for (NSString *key in dic) &#123;</div><div class="line">        if ([self respondsToSelector:@selector(setValue:forKey:)]) &#123;</div><div class="line">            if (class_getProperty([self class], [key UTF8String])) &#123;</div><div class="line">                if (![dic[key] isKindOfClass:[NSNull class]] ) &#123;</div><div class="line">                    [self setValue:dic[key] forKey:key];</div><div class="line">                &#125;else&#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>将数据请求返回的Json字典通过属性映射到各个模型字段中，例如Demo当中有三个对应的返回模型，当然这种对应的返回数据模型和参数模型可以放大每个子业务当中。这里以其中一个为例子：<strong>Type1ResponseModel</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Type1ResponseModel.h</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ZHResponseBaseModel.h&quot;</div><div class="line"></div><div class="line">/***********对应的Json格式*******</div><div class="line">&#123;</div><div class="line"> &quot;responseCode&quot;:&quot;0000&quot;,</div><div class="line"> &quot;responseMsg&quot;:&quot;返回成功&quot;,</div><div class="line"> &quot;remark&quot;:&quot;交流学习&quot;,</div><div class="line"> &quot;userName&quot;:&quot;简书Haofree&quot;,</div><div class="line"> &quot;taskNo&quot;:1</div><div class="line">&#125;</div><div class="line">******************************/</div><div class="line"></div><div class="line">@interface Type1ResponseModel : ZHResponseBaseModel</div><div class="line"></div><div class="line">@property (nonatomic , copy) NSString *responseCode;        //响应结果码</div><div class="line"></div><div class="line">@property (nonatomic , copy) NSString *responseMsg;         //响应消息</div><div class="line"></div><div class="line">@property (nonatomic , copy) NSString *remark;              //备注</div><div class="line"></div><div class="line">@property (nonatomic , copy) NSString *userName;            //名字</div><div class="line"></div><div class="line">@property (nonatomic , assign) NSInteger taskNo;            //索引号</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Type1ResponseModel.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;Type1ResponseModel.h&quot;</div><div class="line"></div><div class="line">@implementation Type1ResponseModel</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样当数据请求返回相应的Json字典时可以清晰解析并且通过KVC属性赋值建起返回的数据模型，当然里时最简单的Json，例子中还涉及到了Json中要嵌套的和数组的这种常见的格式。这种把业务字段封装成返回数据模型方便清晰，也可以放到一个大项目的子模块当中去。</p>
<p><strong>发送参数模型基类ZHParamBaseModel:</strong></p>
<blockquote>
<p>既然返回的数据模型可以提取出来封装，我们业务请求当中还有很多需要发送的参数，这如果分散放在视图控制器中将会很糟糕。同样我们可以将每个业务请求的参数封装在类中，这样修改起来我们不关系视图控制器，只关心这个发送参数类，使得数据业务和视图控制器得到很好的分离。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHParamBaseModel.h</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ZHParamBaseModel : NSObject</div><div class="line"></div><div class="line">-(NSDictionary*)covertToDic;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHParamBaseModel.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ZHParamBaseModel.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation ZHParamBaseModel</div><div class="line"></div><div class="line">- (NSDictionary *)covertToDic&#123;</div><div class="line">    return [self getPropertyList:[self class]];;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)getPropertyList: (Class)clazz</div><div class="line">&#123;</div><div class="line">    u_int count;</div><div class="line">    unsigned int outCount;</div><div class="line">    Ivar* ivars = class_copyIvarList(clazz, &amp;count);</div><div class="line">    objc_property_t *properties = class_copyPropertyList(clazz, &amp;outCount);</div><div class="line">    NSMutableDictionary *propertyDic = [NSMutableDictionary dictionary];</div><div class="line">    for (int i = 0; i &lt; count ; i++)&#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        const char *propName = property_getName(property);</div><div class="line">        </div><div class="line">        id value = [self valueForKey:[NSString stringWithFormat:@&quot;%s&quot;,propName]];</div><div class="line">        if (value == nil || [value isKindOfClass:[NSNull class]]) &#123;</div><div class="line">        &#125;else&#123;</div><div class="line">            [propertyDic setValue:value forKey:[NSString  stringWithCString:propName encoding:NSUTF8StringEncoding] ];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    return propertyDic;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="2、-视图-数据-桥接模型ViewModel层"><a href="#2、-视图-数据-桥接模型ViewModel层" class="headerlink" title="2、(视图-数据)桥接模型ViewModel层"></a>2、(视图-数据)桥接模型ViewModel层</h4><p>(视图-数据)桥接模型ViewModel的基类：<strong>ZHViewBaseModel</strong></p>
<blockquote>
<p>1、将不同的返回的Json字典转换为数据模型<br>2、将接收封装数据模型通过block回调</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHViewBaseModel.h</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">//定义返回请求数据的block类型</div><div class="line">typedef void (^ReturnValueBlock) (id returnValue);</div><div class="line">typedef void (^FailureBlock)(NSUInteger statusCode, NSString *error);</div><div class="line"></div><div class="line">@interface ZHViewBaseModel : NSObject</div><div class="line"></div><div class="line">@property (copy, nonatomic) ReturnValueBlock returnBlock;</div><div class="line">@property (copy, nonatomic) FailureBlock failureBlock;</div><div class="line"></div><div class="line">//接收封装数据请求返回的block</div><div class="line">-(void) setBlockWithReturnBlock: (ReturnValueBlock) returnBlock</div><div class="line">               WithFailureBlock: (FailureBlock) failureBlock;</div><div class="line"></div><div class="line">//将返回的Json字典转换为数据模型</div><div class="line">-(id)process:(NSString*)className dic:(id)response;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ZHViewBaseModel.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ZHViewBaseModel.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">@implementation ZHViewBaseModel</div><div class="line"></div><div class="line">#pragma 接收封装数据请求透穿过来的block</div><div class="line">-(void) setBlockWithReturnBlock: (ReturnValueBlock) returnBlock</div><div class="line">               WithFailureBlock: (FailureBlock) failureBlock&#123;</div><div class="line">    _returnBlock = [returnBlock copy];</div><div class="line">    _failureBlock = [failureBlock copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(id)process:(NSString*)className dic:(id)response&#123;</div><div class="line">    __strong Class model = [NSClassFromString(className) alloc];</div><div class="line">    SEL selector = NSSelectorFromString(@&quot;decodeJsontoDictionary:&quot;);</div><div class="line">    if ([model respondsToSelector:selector]) &#123;</div><div class="line">        [model performSelector:selector withObject:response];</div><div class="line">    &#125;</div><div class="line">    return model;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>另外就是具体处理网络请求出口的公共ViewModel类：<strong>PublicViewBaseModel</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  PublicViewBaseModel.h</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ZHViewBaseModel.h&quot;</div><div class="line"></div><div class="line">@interface PublicViewBaseModel : ZHViewBaseModel</div><div class="line"></div><div class="line">//数据请求层，举例三个数据请求</div><div class="line">- (void)sendType1Request:(NSDictionary*)dic;</div><div class="line"></div><div class="line">- (void)sendType2Request:(NSDictionary*)dic;</div><div class="line"></div><div class="line">- (void)sendType3Request:(NSDictionary*)dic;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  PublicViewBaseModel.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;PublicViewBaseModel.h&quot;</div><div class="line">#import &quot;ZHRequestMethod.h&quot;</div><div class="line"></div><div class="line">@implementation PublicViewBaseModel</div><div class="line"></div><div class="line">- (void)sendType1Request:(NSDictionary*)dic&#123;</div><div class="line">    [self requestNet:dic type:RequestInterfaceNO1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sendType2Request:(NSDictionary*)dic&#123;</div><div class="line">    [self requestNet:dic type:RequestInterfaceNO2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sendType3Request:(NSDictionary*)dic&#123;</div><div class="line">    [self requestNet:dic type:RequestInterfaceNO3];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)requestNet:(NSDictionary*)dic type:(RequestInterface)type&#123;</div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    [ZHRequestMethod startRequest:dic type:type success:^(id responseObject)&#123;</div><div class="line">        NSLog(@&quot;%@&quot;, responseObject);</div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        if (strongSelf) &#123;</div><div class="line">            [strongSelf sucessResponse:responseObject type:type];</div><div class="line">        &#125;</div><div class="line">    &#125;failure:^(NSUInteger statusCode, NSString *error)&#123;</div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        if (strongSelf) &#123;</div><div class="line">            strongSelf.failureBlock(statusCode,error);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sucessResponse:(id)responseObject type:(RequestInterface)type&#123;</div><div class="line">    NSString *className = @&quot;&quot;;</div><div class="line">    switch (type) &#123;</div><div class="line">        case RequestInterfaceNO1:</div><div class="line">            className = @&quot;Type1ResponseModel&quot;;</div><div class="line">            break;</div><div class="line">        case RequestInterfaceNO2:</div><div class="line">            className = @&quot;Type2ResponseModel&quot;;</div><div class="line">            break;</div><div class="line">        case RequestInterfaceNO3:</div><div class="line">            className = @&quot;Type3ResponseModel&quot;;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    id result = [self process:className dic:responseObject];</div><div class="line">    if (self.returnBlock) &#123;</div><div class="line">        self.returnBlock(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="1、视图呈现"><a href="#1、视图呈现" class="headerlink" title="1、视图呈现"></a>1、视图呈现</h4><p>例子中一个视图控制器有三个数据请求和对应的数据，返回数据一个地方处理即可，简洁，需要用到数据的，直接从数据模型中取值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ViewController.m</div><div class="line">//  ZHModel_Demo</div><div class="line">//</div><div class="line">//  Created by haofree on 2017/3/3.</div><div class="line">//  Copyright © 2017年 haofree. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;PublicViewBaseModel.h&quot;</div><div class="line">#import &quot;Type1ResponseModel.h&quot;</div><div class="line">#import &quot;Type2ResponseModel.h&quot;</div><div class="line">#import &quot;Type3ResponseModel.h&quot;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic , strong) PublicViewBaseModel *viewModel;</div><div class="line">@property (nonatomic , strong) Type1ResponseModel  *responseModel_1;</div><div class="line">@property (nonatomic , strong) Type2ResponseModel  *responseModel_2;</div><div class="line">@property (nonatomic , strong) Type3ResponseModel  *responseModel_3;</div><div class="line">@property (nonatomic , strong) Type3ResponseSubListModel  *responseSubListModel_3;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.viewModel = [[PublicViewBaseModel alloc] init];</div><div class="line">    self.responseModel_1 = [[Type1ResponseModel alloc] init];</div><div class="line">    self.responseModel_2 = [[Type2ResponseModel alloc] init];</div><div class="line">    self.responseModel_3 = [[Type3ResponseModel alloc] init];</div><div class="line">    self.responseSubListModel_3 = [[Type3ResponseSubListModel alloc] init];</div><div class="line">    [self getResponseDataModel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回的数据</div><div class="line">- (void) getResponseDataModel&#123;</div><div class="line">    __weak __typeof(self)wekself = self;</div><div class="line">    [self.viewModel setBlockWithReturnBlock:^(id returnValue) &#123;</div><div class="line">        __strong typeof(wekself)strongSelf = wekself;</div><div class="line">        if ([returnValue isKindOfClass:[Type1ResponseModel class]]) &#123;</div><div class="line">            strongSelf.responseModel_1 = (Type1ResponseModel*)returnValue;</div><div class="line">            NSLog(@&quot;responseModel_1:%@&quot;,strongSelf.responseModel_1);</div><div class="line">        &#125;else if ([returnValue isKindOfClass:[Type2ResponseModel class]])&#123;</div><div class="line">            strongSelf.responseModel_2 = (Type2ResponseModel*)returnValue;</div><div class="line">            NSLog(@&quot;responseModel_2:%@&quot;,strongSelf.responseModel_2);</div><div class="line">            </div><div class="line">        &#125;else if ([returnValue isKindOfClass:[Type3ResponseModel class]])&#123;</div><div class="line">            strongSelf.responseModel_3 = (Type3ResponseModel*)returnValue;</div><div class="line">            strongSelf.responseSubListModel_3 = strongSelf.responseModel_3.subTaskList[0];</div><div class="line">            NSLog(@&quot;responseModel_3:%@&quot;,strongSelf.responseModel_3);</div><div class="line">        &#125;else&#123;</div><div class="line">            NSLog(@&quot;无法识别的模型类&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; WithFailureBlock:^(NSUInteger statusCode, NSString *error) &#123;</div><div class="line">        NSLog(@&quot;错误码:%lu,错误信息：%@&quot;,(unsigned long)statusCode,error);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//发送的请求</div><div class="line">- (IBAction)requestBtn1:(id)sender&#123;</div><div class="line">    [self.viewModel sendType1Request:@&#123;&#125;];</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">       </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章分享用于交流学习，一直处于学习积累过程中，文中最开始的思路来自于<a href="https://github.com/lizelu/MVVM">李泽鲁—青玉伏案大神的MVVM工程架构</a>，在这个基础上做了更多的改进。技术的积累，源于吸取，感谢同事和一起学习的朋友，大家批判指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很多人试图解决 MVC 这种架构下 Controller 比较臃肿的问题，这里我分享一种简洁易懂的Model层，致力于打造更为简洁的DataModel和ViewModel层，同时也适用Controller更加简洁。下面一起分享学习。&lt;a href=
    
    </summary>
    
    
      <category term="iOS开发" scheme="https://github.com/SwiftPlayer/SwiftPlayer.github.io.git/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
